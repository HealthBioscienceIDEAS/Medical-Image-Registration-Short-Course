---
title: 'Demons Image Registration'
teaching: 10
exercises: 2
---

:::::::::::::::::::::::::::::::::::::: questions 

- How to understand and visualise three image in one pane for demons image registration algorithm?

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: objectives

- Understanding Demons Image Registration code for 3 images viewing pane

::::::::::::::::::::::::::::::::::::::::::::::::

# Demons Image Registration Algorithm with Multi-Pane Display

This document explains the implementation of a 2D image registration algorithm using the Demons algorithm. The implementation includes visualisation updates within a single window containing three panes for easier comparison of source, target, and warped images.

## 1. Importing Libraries

First, we import the necessary libraries for image processing, transformation, and visualisation.

```python
import matplotlib.pyplot as plt
import numpy as np
from skimage.transform import rescale, resize
from scipy.ndimage.filters import gaussian_filter
from utils3 import dispImage, resampImageWithDefField, calcMSD, dispDefField
```


## 2. Function Definition

The `demonsReg` function is defined to perform the registration between two 2D images using the Demons algorithm. It includes several optional parameters to control the registration process.

```python
def demonsReg(source, target, sigma_elastic=1, sigma_fluid=1, num_lev=3, use_composition=False,
              use_target_grad=False, max_it=1000, check_MSD=True, disp_freq=5, disp_spacing=2, 
              scale_update_for_display=10, disp_method_df='grid', disp_method_up='arrows'):
    """
    Perform a registration between the 2D source image and the 2D target
    image using the demons algorithm. The source image is warped (resampled)
    into the space of the target image.
    
    Parameters:
    - source: 2D numpy array, the source image to be registered.
    - target: 2D numpy array, the target image for registration.
    - sigma_elastic: float, standard deviation for elastic regularisation.
    - sigma_fluid: float, standard deviation for fluid regularisation.
    - num_lev: int, number of levels in the multi-resolution scheme.
    - use_composition: bool, whether to use composition in the update step.
    - use_target_grad: bool, whether to use the target image gradient.
    - max_it: int, maximum number of iterations for the registration.
    - check_MSD: bool, whether to check Mean Squared Difference for improvements.
    - disp_freq: int, frequency of display updates during registration.
    - disp_spacing: int, spacing between grid lines or arrows in display.
    - scale_update_for_display: int, scale factor for displaying the update field.
    - disp_method_df: str, method for displaying the deformation field ('grid' or 'arrows').
    - disp_method_up: str, method for displaying the update field ('grid' or 'arrows').
    
    Returns:
    - warped_image: 2D numpy array, the source image warped into the target image space.
    - def_field: 3D numpy array, the deformation field used to warp the source image.
    """
    # make copies of full resolution images
    source_full = source
    target_full = target
    
    # rest of the function...
```



## 3. Multi-Resolution Scheme and Initialisation

In this step, we initialise variables and set up the multi-resolution scheme by looping over different resolution levels.

```python
# Loop over resolution levels
for lev in range(1, num_lev + 1):
    
    # Resample images if not at the final level
    if lev != num_lev:
        resamp_factor = np.power(2, num_lev - lev)
        target = rescale(target_full, 1.0 / resamp_factor, mode='edge', order=3, anti_aliasing=True)
        source = rescale(source_full, 1.0 / resamp_factor, mode='edge', order=3, anti_aliasing=True)
    else:
        target = target_full
        source = source_full
      
    # If first level, initialise deformation and displacement fields
    if lev == 1:
        X, Y = np.mgrid[0:target.shape[0], 0:target.shape[1]]
        def_field = np.zeros((X.shape[0], X.shape[1], 2))
        def_field[:, :, 0] = X
        def_field[:, :, 1] = Y
        disp_field_x = np.zeros(target.shape)
        disp_field_y = np.zeros(target.shape)
    else:
        # Otherwise, upsample displacement field from previous level
        disp_field_x = 2 * resize(disp_field_x, (target.shape[0], target.shape[1]), mode='edge', order=3)
        disp_field_y = 2 * resize(disp_field_y, (target.shape[0], target.shape[1]), mode='edge', order=3)
        # Recalculate deformation field for this level from displacement field
        X, Y = np.mgrid[0:target.shape[0], 0:target.shape[1]]
        def_field = np.zeros((X.shape[0], X.shape[1], 2))  # Clear def_field from previous level
        def_field[:, :, 0] = X + disp_field_x
        def_field[:, :, 1] = Y + disp_field_y
    
    # Initialise updates
    update_x = np.zeros(target.shape)
    update_y = np.zeros(target.shape)
    update_def_field = np.zeros(def_field.shape)
    
    # Calculate the transformed image at the start of this level
    warped_image = resampImageWithDefField(source, def_field)
    
    # Store the current def_field and MSD value to check for improvements at the end of iteration 
    def_field_prev = def_field.copy()
    prev_MSD = calcMSD(target, warped_image)
    
    # If target image gradient is being used, this can be calculated now as it will not change during the registration
    if use_target_grad:
        img_grad_x, img_grad_y = np.gradient(target)
```